// tests/skill.test.ts
import { describe, it, expect, beforeEach, afterEach, mock } from 'bun:test';
import { BeadsSkill, createSkill } from '../src/skill.js';
import { ConfigManager } from '../src/config/config-manager.js';
import type { SkillContext } from '../src/types/skill.js';

/**
 * Unit tests for skill orchestration
 *
 * Tests the BeadsSkill class and createSkill factory function
 */

// Mock all dependencies
mock.module('../src/clients/beads-client.ts', () => ({
  BeadsClient: mock()
}));
mock.module('../src/backends/github.ts', () => ({
  GitHubBackend: mock(() => ({
    authenticate: mock().mockResolvedValue(undefined)
  }))
}));
mock.module('../src/backends/shortcut.ts', () => ({
  ShortcutBackend: mock(() => ({
    authenticate: mock().mockResolvedValue(undefined)
  }))
}));
mock.module('../src/store/mapping-store.ts', () => ({
  MappingStore: mock()
}));
mock.module('../src/synthesis/progress-synthesizer.ts', () => ({
  ProgressSynthesizer: mock()
}));
mock.module('../src/diagrams/mermaid-generator.ts', () => ({
  MermaidGenerator: mock()
}));
mock.module('../src/diagrams/diagram-placer.ts', () => ({
  DiagramPlacer: mock()
}));
mock.module('../src/discovery/scope-discovery-detector.ts', () => ({
  ScopeDiscoveryDetector: mock()
}));
mock.module('../src/decomposition/epic-decomposer.ts', () => ({
  EpicDecomposer: mock()
}));
mock.module('../src/orchestration/shortcut-sync-orchestrator.js', () => {
  return {
    ShortcutSyncOrchestrator: class {
      constructor() {
        return {};
      }
    }
  };
});
mock.module('../src/monitoring/logger.ts', () => ({
  Logger: mock(() => ({
    info: mock(),
    debug: mock(),
    warn: mock(),
    error: mock(),
    withScope: mock().mockReturnThis()
  }))
}));
mock.module('../src/auth/credential-store.ts', () => ({
  CredentialStore: mock(() => ({
    load: mock().mockResolvedValue({
      github: { token: 'test_token' }
    })
  }))
}));
mock.module('../src/backends/github.js', () => ({
  GitHubBackend: mock(() => ({
    authenticate: mock().mockResolvedValue(undefined)
  }))
}));
mock.module('../src/backends/shortcut.js', () => ({
  ShortcutBackend: mock(() => ({
    authenticate: mock().mockResolvedValue(undefined)
  }))
}));
mock.module('../src/orchestration/shortcut-sync-orchestrator.js', () => ({
  ShortcutSyncOrchestrator: mock(() => {
    return {};
  })
}));
mock.module('../src/backends/shortcut.js', () => ({
  ShortcutBackend: mock()
}));
mock.module('../src/store/mapping-store.js', () => ({
  MappingStore: mock()
}));
mock.module('../src/synthesis/progress-synthesizer.js', () => ({
  ProgressSynthesizer: mock()
}));
mock.module('../src/diagrams/mermaid-generator.js', () => ({
  MermaidGenerator: mock()
}));
mock.module('../src/diagrams/diagram-placer.js', () => ({
  DiagramPlacer: mock()
}));
mock.module('../src/discovery/scope-discovery-detector.js', () => ({
  ScopeDiscoveryDetector: mock()
}));
mock.module('../src/decomposition/epic-decomposer.js', () => ({
  EpicDecomposer: mock()
}));
mock.module('../src/orchestration/shortcut-sync-orchestrator.js', () => ({
  ShortcutSyncOrchestrator: mock()
}));
mock.module('../src/monitoring/logger.js', () => ({
  Logger: mock(() => ({
    info: mock(),
    debug: mock(),
    warn: mock(),
    error: mock(),
    withScope: mock().mockReturnThis()
  }))
}));
mock.module('../src/auth/credential-store.js', () => ({
  CredentialStore: mock(() => ({
    load: mock().mockResolvedValue({
      github: { token: 'test_token' }
    })
  }))
}));

describe('BeadsSkill', () => {
  let skill: BeadsSkill;
  let mockConfig: ConfigManager;

  beforeEach(() => {
    // Create mock config
    mockConfig = {
      getConfig: mock().mockReturnValue({
        version: '2.0',
        backend: 'github',
        github: {
          repository: 'test/test'
        },
        repositories: [
          {
            name: 'test-beads',
            path: '/path/to/beads',
            prefix: 'TEST'
          }
        ],
        mappingStoragePath: '/path/to/mappings',
        logging: {
          level: 'info'
        }
      })
    } as any;

    const credentials = {
      github: { token: 'test_token', scopes: ['repo'] }
    };

    skill = new BeadsSkill(mockConfig, credentials);
  });

  afterEach(() => {
    mock.restore();
  });

  describe('Constructor', () => {
    it('should initialize with config and credentials', () => {
      expect(skill).toBeDefined();
      expect(mockConfig.getConfig).toHaveBeenCalled();
    });

    it('should instantiate ShortcutSyncOrchestrator when backend is shortcut', () => {
      // Create mock config with shortcut backend
      const shortcutConfig = {
        getConfig: mock().mockReturnValue({
          version: '2.0',
          backend: 'shortcut',
          repositories: [
            {
              name: 'test-beads',
              path: '/path/to/beads',
              prefix: 'TEST'
            }
          ],
          mappingStoragePath: '/path/to/mappings',
          logging: {
            level: 'info'
          }
        })
      } as any;

      const credentials = {
        shortcut: { token: 'test_token' }
      };

      const shortcutSkill = new BeadsSkill(shortcutConfig, credentials);

      // Access private property for testing
      expect((shortcutSkill as any).shortcutSyncOrchestrator).toBeDefined();
    });

    it('should not instantiate ShortcutSyncOrchestrator when backend is github', () => {
      // Access private property for testing
      expect((skill as any).shortcutSyncOrchestrator).toBeUndefined();
    });
  });

  describe('execute()', () => {
    it('should throw error for unknown capability', async () => {
      const context: SkillContext = {
        repository: 'test/test',
        issueNumber: 1
      };

      const result = await skill.execute('unknown_capability' as any, context);

      expect(result.success).toBe(false);
      expect(result.error?.message).toContain('Unknown capability');
    });
  });

  describe('queryStatus()', () => {
    it('should return error if repository missing', async () => {
      const context: SkillContext = {
        issueNumber: 1
      };

      const result = await skill.execute('query_status', context);

      expect(result.success).toBe(false);
      expect(result.error?.code).toBe('VALIDATION_ERROR');
    });

    it('should return error if issueNumber missing', async () => {
      const context: SkillContext = {
        repository: 'test/test'
      };

      const result = await skill.execute('query_status', context);

      expect(result.success).toBe(false);
      expect(result.error?.code).toBe('VALIDATION_ERROR');
    });
  });

  describe('syncProgress()', () => {
    it('should validate required fields', async () => {
      const context: SkillContext = {};

      const result = await skill.execute('sync_progress', context);

      expect(result.success).toBe(false);
      expect(result.error?.code).toBe('VALIDATION_ERROR');
    });

    it('should route to ShortcutSyncOrchestrator when backend is shortcut', async () => {
      // Create mock config with shortcut backend
      const shortcutConfig = {
        getConfig: mock().mockReturnValue({
          version: '2.0',
          backend: 'shortcut',
          repositories: [
            {
              name: 'test-beads',
              path: '/path/to/beads',
              prefix: 'TEST'
            }
          ],
          mappingStoragePath: '/path/to/mappings',
          logging: {
            level: 'info'
          }
        })
      } as any;

      const credentials = {
        shortcut: { token: 'test_token' }
      };

      const shortcutSkill = new BeadsSkill(shortcutConfig, credentials);

      // Mock the orchestrator's syncStory method
      const mockSyncStory = mock().mockResolvedValue({
        success: true,
        storyId: 123,
        storyUrl: 'https://shortcut.com/story/123',
        commentUrl: 'https://shortcut.com/story/123#comment-456',
        syncedAt: '2025-11-10T12:00:00Z'
      });
      (shortcutSkill as any).shortcutSyncOrchestrator = {
        syncStory: mockSyncStory
      };

      // Mock backend name property
      (shortcutSkill as any).backend = { name: 'shortcut' };

      const context: SkillContext = {
        repository: 'shortcut',
        issueNumber: 123,
        userNarrative: 'Test narrative'
      };

      const result = await shortcutSkill.execute('sync_progress', context);

      expect(mockSyncStory).toHaveBeenCalledWith(123, {
        userNarrative: 'Test narrative'
      });
      expect(result.success).toBe(true);
      expect(result.data).toEqual({
        storyUrl: 'https://shortcut.com/story/123',
        commentUrl: 'https://shortcut.com/story/123#comment-456',
        syncedAt: '2025-11-10T12:00:00Z'
      });
    });

    it('should use ProgressSynthesizer for GitHub backend', async () => {
      const context: SkillContext = {
        repository: 'test/test',
        issueNumber: 123
      };

      // Mock the progressSynthesizer's updateIssueProgress method
      const mockUpdateIssueProgress = mock().mockResolvedValue({
        success: true,
        commentUrl: 'https://github.com/test/test/issues/123#issuecomment-456'
      });
      (skill as any).progressSynthesizer = {
        updateIssueProgress: mockUpdateIssueProgress
      };

      // Mock backend name property
      (skill as any).backend = { name: 'github' };

      const result = await skill.execute('sync_progress', context);

      expect(mockUpdateIssueProgress).toHaveBeenCalledWith(
        'test/test',
        123,
        {
          includeBlockers: true,
          includeDiagram: true
        }
      );
      expect(result.success).toBe(true);
    });

    it('should pass userNarrative to orchestrator', async () => {
      // Create mock config with shortcut backend
      const shortcutConfig = {
        getConfig: mock().mockReturnValue({
          version: '2.0',
          backend: 'shortcut',
          repositories: [
            {
              name: 'test-beads',
              path: '/path/to/beads',
              prefix: 'TEST'
            }
          ],
          mappingStoragePath: '/path/to/mappings',
          logging: {
            level: 'info'
          }
        })
      } as any;

      const credentials = {
        shortcut: { token: 'test_token' }
      };

      const shortcutSkill = new BeadsSkill(shortcutConfig, credentials);

      // Mock the orchestrator's syncStory method
      const mockSyncStory = mock().mockResolvedValue({
        success: true,
        storyId: 123,
        storyUrl: 'https://shortcut.com/story/123',
        syncedAt: '2025-11-10T12:00:00Z'
      });
      (shortcutSkill as any).shortcutSyncOrchestrator = {
        syncStory: mockSyncStory
      };

      // Mock backend name property
      (shortcutSkill as any).backend = { name: 'shortcut' };

      const context: SkillContext = {
        repository: 'shortcut',
        issueNumber: 123,
        userNarrative: 'My custom narrative for this update'
      };

      await shortcutSkill.execute('sync_progress', context);

      expect(mockSyncStory).toHaveBeenCalledWith(123, {
        userNarrative: 'My custom narrative for this update'
      });
    });
  });

  describe('generateDiagrams()', () => {
    it('should validate required fields', async () => {
      const context: SkillContext = {};

      const result = await skill.execute('generate_diagrams', context);

      expect(result.success).toBe(false);
      expect(result.error?.code).toBe('VALIDATION_ERROR');
    });
  });

  describe('manageMappings()', () => {
    it('should validate required fields', async () => {
      const context: SkillContext = {
        action: 'get'
      };

      const result = await skill.execute('manage_mappings', context);

      expect(result.success).toBe(false);
      expect(result.error?.code).toBe('VALIDATION_ERROR');
    });

    it('should validate epicIds for create action', async () => {
      const context: SkillContext = {
        repository: 'test/test',
        issueNumber: 1,
        action: 'create'
      };

      const result = await skill.execute('manage_mappings', context);

      expect(result.success).toBe(false);
      expect(result.error?.code).toBe('VALIDATION_ERROR');
      expect(result.error?.message).toContain('epicIds array is required');
    });

    it('should validate epic structure', async () => {
      const context: SkillContext = {
        repository: 'test/test',
        issueNumber: 1,
        action: 'create',
        epicIds: [
          { repository: 'test' } // Missing epicId and repositoryPath
        ] as any
      };

      const result = await skill.execute('manage_mappings', context);

      expect(result.success).toBe(false);
      expect(result.error?.code).toBe('VALIDATION_ERROR');
      expect(result.error?.message).toContain('repository, epicId, and repositoryPath');
    });
  });

  describe('decompose()', () => {
    it('should validate required fields', async () => {
      const context: SkillContext = {};

      const result = await skill.execute('decompose', context);

      expect(result.success).toBe(false);
      expect(result.error?.code).toBe('VALIDATION_ERROR');
    });
  });

  describe('forceSync()', () => {
    it('should validate required fields', async () => {
      const context: SkillContext = {};

      const result = await skill.execute('force_sync', context);

      expect(result.success).toBe(false);
      expect(result.error?.code).toBe('VALIDATION_ERROR');
    });
  });

  describe('getMetadata()', () => {
    it('should return skill metadata', () => {
      const metadata = skill.getMetadata();

      expect(metadata.name).toBe('beads-bridge-integration');
      expect(metadata.version).toBe('1.0.0');
      expect(metadata.capabilities).toContain('query_status');
      expect(metadata.capabilities).toContain('sync_progress');
      expect(metadata.capabilities).toContain('generate_diagrams');
      expect(metadata.capabilities).toContain('manage_mappings');
      expect(metadata.capabilities).toContain('decompose');
      expect(metadata.capabilities).toContain('force_sync');
    });
  });
});

describe('createSkill()', () => {
  beforeEach(() => {
    mock.restore();
  });

  it('should create skill instance', async () => {
    mock.module('../src/config/config-manager.js', () => ({
      ConfigManager: {
        load: mock().mockResolvedValue({
          getConfig: mock().mockReturnValue({
            version: '2.0',
            backend: 'github',
            github: { repository: 'test/test' },
            repositories: [{ name: 'test', path: '/path', prefix: 'TEST' }],
            mappingStoragePath: '/path',
            logging: { level: 'info' }
          })
        })
      }
    }));

    const skill = await createSkill();

    expect(skill).toBeDefined();
    expect(skill).toBeInstanceOf(BeadsSkill);
  });
});
